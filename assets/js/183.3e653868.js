(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{692:function(e,t,n){"use strict";n.r(t);var a=n(65),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"dependency-graph"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dependency-graph"}},[e._v("#")]),e._v(" Dependency graph")]),e._v(" "),n("p",[e._v("For accuracy and performance, HyperFormula needs to process cells in a correct and optimal order. For example: in formula "),n("code",[e._v("C1=A1+B1")]),e._v(", cells "),n("code",[e._v("A1")]),e._v(" and "),n("code",[e._v("B1")]),e._v(" need to be evaluated before "),n("code",[e._v("C1")]),e._v(".")]),e._v(" "),n("p",[e._v("To find the right order of processing cells, HyperFormula builds a "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Dependency_graph",target:"_blank",rel:"noopener noreferrer"}},[e._v("dependency graph"),n("OutboundLink")],1),e._v(" which captures relationships between cells.")]),e._v(" "),n("h2",{attrs:{id:"cells-in-the-dependency-graph"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cells-in-the-dependency-graph"}},[e._v("#")]),e._v(" Cells in the dependency graph")]),e._v(" "),n("p",[e._v("In the dependency graph, each spreadsheet cell is represented by a separate node.")]),e._v(" "),n("p",[e._v("Nodes "),n("code",[e._v("X")]),e._v(" and "),n("code",[e._v("Y")]),e._v(" are connected by a directed edge if and only if the formula in cell "),n("code",[e._v("X")]),e._v(" includes the address of cell "),n("code",[e._v("Y")]),e._v(".")]),e._v(" "),n("h2",{attrs:{id:"ranges-in-the-dependency-graph"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ranges-in-the-dependency-graph"}},[e._v("#")]),e._v(" Ranges in the dependency graph")]),e._v(" "),n("p",[e._v("If formulas in the spreadsheet include ranges, each range is represented by a separate node.\nThe dependency graph may also contain ranges that are not used by any formula, for better optimization.")]),e._v(" "),n("p",[e._v("Range nodes can be connected to cell nodes and to other range nodes.")]),e._v(" "),n("img",{attrs:{src:e.$withBase("/ranges.png")}}),e._v(" "),n("h3",{attrs:{id:"optimizations-for-large-ranges"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#optimizations-for-large-ranges"}},[e._v("#")]),e._v(" Optimizations for large ranges")]),e._v(" "),n("p",[e._v("In many applications, you may want to use formulas that depend on a\nlarge range of cells. For example, the formula "),n("code",[e._v("SUM(A1:A100)+B5")]),e._v("\ndepends on 101 cells, and it needs to be represented in the dependency graph accordingly.")]),e._v(" "),n("p",[e._v("An interesting optimization challenge arises when there are multiple\ncells that depend on large ranges. For example, consider the following\nuse-case:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("B1=SUM(A1:A1)")])]),e._v(" "),n("li",[n("code",[e._v("B2=SUM(A1:A2)")])]),e._v(" "),n("li",[n("code",[e._v("B3=SUM(A1:A3)")])]),e._v(" "),n("li",[e._v("...")]),e._v(" "),n("li",[n("code",[e._v("B100=SUM(A1:A100)")])])]),e._v(" "),n("p",[e._v("The problem is that there are "),n("code",[e._v("1+2+3+...+100 = 5050")]),e._v(" dependencies\nfor such a simple situation. In general, for "),n("code",[e._v("n")]),e._v(" such rows, the\nengine would need to add "),n("code",[e._v("n*(n+1)/2 ≈ n²")]),e._v(" arcs in the graph. This\nvalue grows much faster than the size of data, meaning the engine\nwould not be able to handle large data sets efficiently.")]),e._v(" "),n("p",[e._v("A solution to this problem comes from the observation that there is\na way to rewrite the above formulas to equivalent ones, which will\nbe more compact to represent. Specifically, the following formulas\nwould compute the same values as the ones provided previously:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("B1=A1")])]),e._v(" "),n("li",[n("code",[e._v("B2=B1+A2")])]),e._v(" "),n("li",[n("code",[e._v("B3=B2+A3")])]),e._v(" "),n("li",[e._v("...")]),e._v(" "),n("li",[n("code",[e._v("B100=B99+A100")])])]),e._v(" "),n("p",[e._v("Whereas this example is too specialized to provide a useful rule\nfor optimization, it shows the main idea behind efficient handling\nof multiple ranges: "),n("strong",[e._v("to represent a range as a composition of\nsmaller ranges.")])]),e._v(" "),n("p",[e._v("In the adopted implementation, every time the engine encounters a\nrange, say "),n("code",[e._v("B5:D20")]),e._v(", it checks if it has already considered the\nrange which is one row shorter. In this example, it would be "),n("code",[e._v("B5:D19")]),e._v(".\nIf so, then it represents "),n("code",[e._v("B5:D20")]),e._v(" as the composition of a range\n"),n("code",[e._v("B5:D19")]),e._v(" and three cells in the last row: "),n("code",[e._v("B20")]),e._v(","),n("code",[e._v("C20")]),e._v(" and "),n("code",[e._v("D20")]),e._v(".")]),e._v(" "),n("img",{attrs:{src:e.$withBase("/ranges.png")}}),e._v(" "),n("p",[e._v("More generally, the result of any associative operation is obtained\nas the result of operations for these small rows. There are many\nexamples of such associative functions: "),n("code",[e._v("SUM")]),e._v(", "),n("code",[e._v("MAX")]),e._v(", "),n("code",[e._v("COUNT")]),e._v(", etc.\nAs one range can be used in different formulas, we can reuse its\nnode and avoid duplicating the work during computation.")]),e._v(" "),n("h2",{attrs:{id:"getting-the-immediate-precedents-of-a-cell-or-a-range"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getting-the-immediate-precedents-of-a-cell-or-a-range"}},[e._v("#")]),e._v(" Getting the immediate precedents of a cell or a range")]),e._v(" "),n("p",[e._v("To get the immediate precedents of a cell or a range (the in-neighbors of the cell node or the range node), use the "),n("RouterLink",{attrs:{to:"/api/classes/hyperformula.html#getcellprecedents"}},[n("code",[e._v("getCellPrecedents()")])]),e._v(" method:")],1),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n\nhfInstance.getCellPrecedents({ sheet: 0, col: 2, row: 0});\n// returns [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]\n")])])]),n("h2",{attrs:{id:"getting-the-immediate-dependents-of-a-cell-or-a-range"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getting-the-immediate-dependents-of-a-cell-or-a-range"}},[e._v("#")]),e._v(" Getting the immediate dependents of a cell or a range")]),e._v(" "),n("p",[e._v("To get the immediate dependents of a cell or a range (the out-neighbors of the cell node or the range node), use the "),n("RouterLink",{attrs:{to:"/api/classes/hyperformula.html#getcelldependents"}},[n("code",[e._v("getCellDependents()")])]),e._v(" method:")],1),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );\n\nhfInstance.getCellDependents({ sheet: 0, col: 2, row: 0});\n// returns [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]\n")])])]),n("h2",{attrs:{id:"getting-all-precedents-of-a-cell-or-a-range"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getting-all-precedents-of-a-cell-or-a-range"}},[e._v("#")]),e._v(" Getting all precedents of a cell or a range")]),e._v(" "),n("p",[e._v("To get all precedents of a cell or a range (all precedent nodes reachable from the cell node or the range node), use the "),n("RouterLink",{attrs:{to:"/api/classes/hyperformula.html#getcellprecedents"}},[n("code",[e._v("getCellPrecedents()")])]),e._v(" method to implement a "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Breadth-first_search",target:"_blank",rel:"noopener noreferrer"}},[e._v("Breadth-first search (BFS)"),n("OutboundLink")],1),e._v(" algorithm:")],1),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" 1      AllCellPrecedents={start}\n 2      let Q be an empty queue\n 4      Q.enqueue(start)\n 5      while Q is not empty do\n 6          cell := Q.dequeue()\n 7          S := getCellPrecedents(cell)\n 9          for all cells c in S do:\n10              if c is not in AllCellPrecedents then:\n11                  insert w to AllCellPrecedents\n12                  Q.enqueue(c)\n")])])]),n("h2",{attrs:{id:"getting-all-dependents-of-a-cell-or-a-range"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getting-all-dependents-of-a-cell-or-a-range"}},[e._v("#")]),e._v(" Getting all dependents of a cell or a range")]),e._v(" "),n("p",[e._v("To get all dependents of a cell or a range (all dependent nodes reachable from the cell node or the range node), use the "),n("RouterLink",{attrs:{to:"/api/classes/hyperformula.html#getcelldependents"}},[n("code",[e._v("getCellDependents()")])]),e._v(" method to implement a "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Breadth-first_search",target:"_blank",rel:"noopener noreferrer"}},[e._v("Breadth-first search (BFS)"),n("OutboundLink")],1),e._v(" algorithm:")],1),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" 1      AllCellDependents={start}\n 2      let Q be an empty queue\n 4      Q.enqueue(start)\n 5      while Q is not empty do\n 6          cell := Q.dequeue()\n 7          S := getCellDependents(cell)\n 9          for all cells c in S do:\n10              if c is not in AllCellDependents then:\n11                  insert w to AllCellDependents\n12                  Q.enqueue(c)\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);